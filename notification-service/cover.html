
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>notification: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.crja72.ru/gospec/go9/netevent/notification-service/cmd/notification/main.go (0.0%)</option>
				
				<option value="file1">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/config/config.go (0.0%)</option>
				
				<option value="file2">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/notification/notification.go (0.0%)</option>
				
				<option value="file3">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/broker/kafka/errors.go (0.0%)</option>
				
				<option value="file4">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/broker/kafka/kafka.go (0.0%)</option>
				
				<option value="file5">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/database/adapter.go (0.0%)</option>
				
				<option value="file6">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/database/db.go (0.0%)</option>
				
				<option value="file7">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/database/queries.sql.go (0.0%)</option>
				
				<option value="file8">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/service/notification/errors.go (0.0%)</option>
				
				<option value="file9">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/service/notification/parser.go (0.0%)</option>
				
				<option value="file10">gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/service/notification/sender.go (81.8%)</option>
				
				<option value="file11">gitlab.crja72.ru/gospec/go9/netevent/notification-service/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file12">gitlab.crja72.ru/gospec/go9/netevent/notification-service/pkg/mail/gmail/gmail.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "syscall"
        "time"

        _ "github.com/lib/pq"

        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/config"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/notification"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/pkg/logger"
)

const stopTimeout = 3 * time.Second

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        os.Exit(mainWithExitCode(ctx))
}</span>

func mainWithExitCode(ctx context.Context) (exitCode int) <span class="cov0" title="0">{
        app := notification.New()

        cfg, err := config.New()
        if err != nil </span><span class="cov0" title="0">{
                logger.Default().Errorf(ctx, "failed to get config: %s", err)
                return 1
        }</span>

        <span class="cov0" title="0">if err := app.Initialize(ctx, cfg); err != nil </span><span class="cov0" title="0">{
                logger.Default().Errorf(ctx, "failed to initialize app: %s", err)
                return 1
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := app.Run(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Default().Errorf(ctx, "failed to run app: %s", err)
                        os.Exit(2)
                }</span>
        }()

        <span class="cov0" title="0">graceCh := make(chan os.Signal, 1)
        signal.Notify(graceCh, syscall.SIGINT, syscall.SIGTERM)
        &lt;-graceCh

        ctx, cancel := context.WithTimeout(ctx, stopTimeout)
        defer cancel()

        logger.Default().Infof(ctx, "Graceful shutdown...")

        if err := app.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Default().Infof(ctx, "Telegram application shutdown error: %s", err)
                return 3
        }</span>

        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        Database DB
        Mail     Mail
        Kafka    Kafka
        Sender   Sender
}

type DB struct {
        SQL SQL
}

type SQL struct {
        ConnectionString string `env:"DB_URL"    env-default:"postgres://postgres:123@localhost:5432/netevent?sslmode=disable"`
        Driver           string `env:"DB_DRIVER" env-default:"postgres"`
}

type Mail struct {
        Host     string `env:"MAIL_HOST"`
        Port     int    `env:"MAIL_PORT" env-default:"587"`
        Username string `env:"MAIL_USERNAME"`
        Password string `env:"MAIL_PASSWORD"`
}

type Kafka struct {
        Host  string `env:"KAFKA_HOST"  env-default:"localhost"`
        Port  int    `env:"KAFKA_PORT"  env-default:"9092"`
        Group string `env:"KAFKA_GROUP" env-default:"mail-group"`
        Topic string `env:"KAFKA_TOPIC" env-default:"mail"`
}

type Sender struct {
        SecondInterval int `env:"SENDER_SECOND_INTERVAL"  env-default:"3600"`
}

func New() (*Config, error) <span class="cov0" title="0">{
        cfg := Config{}
        if err := cleanenv.ReadConfig("./.env", &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cleanenv.ReadConfig(): %w", err)
        }</span>

        <span class="cov0" title="0">if err := cleanenv.ReadEnv(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cleanenv.ReadEnv(): %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package notification

import (
        "context"
        "errors"
        "fmt"

        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/config"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/broker/kafka"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/database"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/service/notification"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/pkg/mail/gmail"
        "golang.org/x/sync/errgroup"
)

type Closer = func() error

type Application struct {
        kafka   *kafka.Kafka
        sender  *notification.Sender
        closers []Closer
}

func New() *Application <span class="cov0" title="0">{
        return &amp;Application{
                closers: make([]Closer, 0),
        }
}</span>

func (a *Application) Initialize(ctx context.Context, cfg *config.Config) error <span class="cov0" title="0">{
        db, err := database.NewAdapter(ctx, cfg.Database.SQL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database: %w", err)
        }</span>

        <span class="cov0" title="0">a.closers = append(a.closers, db.Close)

        parser := notification.NewParser(db)

        kfk, err := kafka.New(cfg.Kafka, parser)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka.New(): %w", err)
        }</span>

        <span class="cov0" title="0">a.kafka = kfk

        mail := gmail.New(cfg.Mail)
        a.sender = notification.NewSender(cfg.Sender, db, mail)

        return nil</span>
}

func (a *Application) Run(ctx context.Context) error <span class="cov0" title="0">{
        eg := errgroup.Group{}

        eg.Go(func() error </span><span class="cov0" title="0">{
                if err := a.sender.Run(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error running sender: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">eg.Go(func() error </span><span class="cov0" title="0">{
                if err := a.kafka.Run(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error running kafka klient: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("eg.Wait(): %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *Application) Stop(ctx context.Context) error <span class="cov0" title="0">{
        errs := make([]error, 0)

        if err := a.kafka.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("a.kafka.Stop(ctx): %w", err))
        }</span>

        <span class="cov0" title="0">if err := a.sender.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("a.sender.Stop(ctx): %w", err))
        }</span>

        <span class="cov0" title="0">for _, closer := range a.closers </span><span class="cov0" title="0">{
                if err := closer(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop: %w", errors.Join(errs...))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package kafka

import "fmt"

type ErrStopKafkaConsumer struct{}

func NewErrStopKafkaConsumer() error <span class="cov0" title="0">{
        return ErrStopKafkaConsumer{}
}</span>

func (e ErrStopKafkaConsumer) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("failed to stop kafka consumer")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package kafka

import (
        "context"
        "fmt"

        "github.com/IBM/sarama"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/config"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/pkg/logger"
)

type Closer = func() error

type Kafka struct {
        group   sarama.ConsumerGroup
        handler sarama.ConsumerGroupHandler
        topics  []string
        done    chan struct{}
        stopped chan struct{}
}

func New(cfg config.Kafka, handler sarama.ConsumerGroupHandler) (*Kafka, error) <span class="cov0" title="0">{
        config := sarama.NewConfig()
        config.Consumer.Return.Errors = true

        group, err := sarama.NewConsumerGroup([]string{fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)}, cfg.Group, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new kafka consumer: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Kafka{
                group:   group,
                handler: handler,
                topics:  []string{cfg.Topic},
        }, nil</span>
}

func (k *Kafka) Run(ctx context.Context) error <span class="cov0" title="0">{
        // Track errors
        go func() </span><span class="cov0" title="0">{
                for err := range k.group.Errors() </span><span class="cov0" title="0">{
                        logger.Default().Errorf(ctx, "kafka group error: %s", err)
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-k.done:<span class="cov0" title="0">
                        close(k.stopped)

                        return nil</span>

                default:<span class="cov0" title="0">
                        err := k.group.Consume(ctx, k.topics, k.handler)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Default().Errorf(ctx, "failed to consume messages: %s", err)
                        }</span>
                }
        }
}

func (k *Kafka) Stop(ctx context.Context) error <span class="cov0" title="0">{
        close(k.done)

        select </span>{
        case &lt;-k.stopped:<span class="cov0" title="0">
                break</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                return NewErrStopKafkaConsumer()</span>
        }

        <span class="cov0" title="0">if err := k.group.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close consumer group: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/config"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/domain"
)

type Closer = func() error

type DBAdapter struct {
        queries *Queries
        closers []Closer
}

func NewAdapter(ctx context.Context, cfg config.SQL) (*DBAdapter, error) <span class="cov0" title="0">{
        closers := make([]Closer, 0)

        sqlDB, err := sql.Open(cfg.Driver, cfg.ConnectionString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">closers = append(closers, sqlDB.Close)

        return &amp;DBAdapter{
                queries: New(sqlDB),
                closers: closers,
        }, nil</span>
}

func (db *DBAdapter) GetNotifications(ctx context.Context) ([]domain.Notification, error) <span class="cov0" title="0">{
        res, err := db.queries.GetNotifications(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get notifications: %w", err)
        }</span>

        <span class="cov0" title="0">notifies := make([]domain.Notification, 0, len(res))
        for _, v := range res </span><span class="cov0" title="0">{
                notifies = append(notifies, dbNotificationToGlobal(v))
        }</span>

        <span class="cov0" title="0">return notifies, nil</span>
}

func (db *DBAdapter) AddNotification(ctx context.Context, notify domain.Notification) (domain.Notification, error) <span class="cov0" title="0">{
        tm, err := time.Parse(time.DateTime, notify.EventTime)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Notification{}, fmt.Errorf("failed to parse time: %w", err)
        }</span>

        <span class="cov0" title="0">args := AddNotificationParams{
                UserName:   notify.UserName,
                UserEmail:  notify.UserEmail,
                EventName:  notify.EventName,
                EventPlace: notify.EventPlace,
                EventTime:  tm,
        }

        res, err := db.queries.AddNotification(ctx, args)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Notification{}, fmt.Errorf("failed to add notification: %w", err)
        }</span>

        <span class="cov0" title="0">return dbNotificationToGlobal(res), nil</span>
}

func (db *DBAdapter) DeleteNotification(ctx context.Context, id int64) (domain.Notification, error) <span class="cov0" title="0">{
        res, err := db.queries.DeleteNotification(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Notification{}, fmt.Errorf("failed to delete notification: %w", err)
        }</span>

        <span class="cov0" title="0">return dbNotificationToGlobal(res), nil</span>
}

func (db *DBAdapter) Close() error <span class="cov0" title="0">{
        errs := make([]error, 0)

        for _, closer := range db.closers </span><span class="cov0" title="0">{
                if err := closer(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close database: %w", errors.Join(errs...))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func dbNotificationToGlobal(notify Notification) domain.Notification <span class="cov0" title="0">{
        return domain.Notification{
                ID:         notify.ID,
                UserName:   notify.UserName,
                UserEmail:  notify.UserEmail,
                EventName:  notify.EventName,
                EventPlace: notify.EventPlace,
                EventTime:  notify.EventTime.Format(time.DateTime),
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package database

import (
        "context"
        "database/sql"
)

type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
        "context"
        "time"
)

const addNotification = `-- name: AddNotification :one
INSERT INTO notifications(user_name, user_email, event_name, event_place, event_time)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_name, user_email, event_name, event_place, event_time
`

type AddNotificationParams struct {
        UserName   string
        UserEmail  string
        EventName  string
        EventPlace string
        EventTime  time.Time
}

func (q *Queries) AddNotification(ctx context.Context, arg AddNotificationParams) (Notification, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, addNotification,
                arg.UserName,
                arg.UserEmail,
                arg.EventName,
                arg.EventPlace,
                arg.EventTime,
        )
        var i Notification
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserName,
                &amp;i.UserEmail,
                &amp;i.EventName,
                &amp;i.EventPlace,
                &amp;i.EventTime,
        )
        return i, err
}</span>

const deleteNotification = `-- name: DeleteNotification :one
DELETE FROM notifications
WHERE id = $1
RETURNING id, user_name, user_email, event_name, event_place, event_time
`

func (q *Queries) DeleteNotification(ctx context.Context, id int64) (Notification, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, deleteNotification, id)
        var i Notification
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserName,
                &amp;i.UserEmail,
                &amp;i.EventName,
                &amp;i.EventPlace,
                &amp;i.EventTime,
        )
        return i, err
}</span>

const getNotifications = `-- name: GetNotifications :many
SELECT 
        id, user_name, user_email, event_name, event_place, event_time
FROM notifications
WHERE AGE(NOW(), event_time) &lt;= INTERVAL '1 day'
`

func (q *Queries) GetNotifications(ctx context.Context) ([]Notification, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getNotifications)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Notification
        for rows.Next() </span><span class="cov0" title="0">{
                var i Notification
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserName,
                        &amp;i.UserEmail,
                        &amp;i.EventName,
                        &amp;i.EventPlace,
                        &amp;i.EventTime,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package notification

import "fmt"

type ErrStopSender struct{}

func NewErrStopSender() error <span class="cov0" title="0">{
        return ErrStopSender{}
}</span>

func (e ErrStopSender) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("failed to stop sender")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package notification

import (
        "context"
        "encoding/json"

        "github.com/IBM/sarama"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/domain"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/pkg/logger"
)

//go:generate mockery --name NotificationRepository  --structname MockNotificationRepository --filename mock_notification_repository_test.go --outpkg notification_test --output .
type NotificationRepository interface {
        GetNotifications(ctx context.Context) ([]domain.Notification, error)
        AddNotification(ctx context.Context, notify domain.Notification) (domain.Notification, error)
        DeleteNotification(ctx context.Context, id int64) (domain.Notification, error)
}

type Parser struct {
        repo NotificationRepository
}

func NewParser(repo NotificationRepository) *Parser <span class="cov0" title="0">{
        return &amp;Parser{
                repo: repo,
        }
}</span>

// To implement sarama.ConsumerGroupHandler interface
func (s *Parser) Setup(_ sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        return nil
}</span>

// To implement sarama.ConsumerGroupHandler interface
func (s *Parser) Cleanup(_ sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *Parser) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error <span class="cov0" title="0">{
        ctx := context.Background()

        for msg := range claim.Messages() </span><span class="cov0" title="0">{
                sess.MarkMessage(msg, "")

                var notification domain.Notification

                if err := json.Unmarshal(msg.Value, &amp;notification); err != nil </span><span class="cov0" title="0">{
                        logger.Default().Errorf(ctx, "failed to unmarshal message %q: %s", msg.Value, err)
                        continue</span>
                }

                <span class="cov0" title="0">_, err := s.repo.AddNotification(ctx, notification)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Default().Errorf(ctx, "failed add notification: %s", err)
                        continue</span>
                }

        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package notification

import (
        "context"
        "fmt"
        "time"

        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/config"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/domain"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/pkg/logger"
)

//go:generate mockery --name Mail --structname MockMail --filename mock_mail_test.go --outpkg notification_test --output .
type Mail interface {
        Send(subject string, msg domain.Notification) error
}

type Sender struct {
        repo     NotificationRepository
        mail     Mail
        interval time.Duration
        done     chan struct{}
        stopped  chan struct{}
}

func NewSender(cfg config.Sender, repo NotificationRepository, mail Mail) *Sender <span class="cov8" title="1">{
        return &amp;Sender{
                repo:     repo,
                mail:     mail,
                interval: time.Second * time.Duration(cfg.SecondInterval),
                done:     make(chan struct{}),
                stopped:  make(chan struct{}),
        }
}</span>

func (s *Sender) Run(ctx context.Context) error <span class="cov8" title="1">{
        defer close(s.stopped)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.done:<span class="cov8" title="1">
                        fmt.Println("ok")
                        return nil</span>

                default:<span class="cov8" title="1">
                        fmt.Println("default")
                        notifications, err := s.repo.GetNotifications(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Default().Errorf(ctx, "failed to get notifications: %s", err)
                        }</span>

                        <span class="cov8" title="1">for _, notify := range notifications </span><span class="cov8" title="1">{
                                if err := s.mail.Send(notify.EventName, notify); err != nil </span><span class="cov0" title="0">{
                                        logger.Default().Errorf(ctx, "failed to send notification: %s", err)
                                }</span>

                                <span class="cov8" title="1">_, err := s.repo.DeleteNotification(ctx, notify.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Default().Errorf(ctx, "failed to delete notification with id = %d: %s", notify.ID, err)
                                }</span>
                        }

                        <span class="cov8" title="1">time.Sleep(s.interval)</span>
                }
        }
}

func (s *Sender) Stop(ctx context.Context) error <span class="cov8" title="1">{
        close(s.done)

        select </span>{
        case &lt;-s.stopped:<span class="cov8" title="1">
                break</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                return NewErrStopSender()</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package logger

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
)

const (
        LoggerKey   = "logger"
        RequestID   = "requestID"
        ServiceName = "serviceName"
)

type Logger interface {
        Infof(ctx context.Context, msg string, args ...any)
        Errorf(ctx context.Context, msg string, args ...any)
        Fatalf(ctx context.Context, msg string, args ...any)
}

type logger struct {
        logger      *slog.Logger
        serviceName string
}

func New(w io.Writer, lvl slog.Level, serviceName string) Logger <span class="cov0" title="0">{
        return &amp;logger{
                logger: slog.New(slog.NewJSONHandler(w, &amp;slog.HandlerOptions{
                        Level: lvl,
                })),
                serviceName: serviceName,
        }
}</span>

var defaultLogger = &amp;logger{
        logger: slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })),
        serviceName: "default",
}

func Default() Logger <span class="cov0" title="0">{
        return defaultLogger
}</span>

func (l *logger) Infof(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        attrs := make([]any, 0)
        attrs = append(attrs, slog.String("serviceName", l.serviceName))

        reqID := ctx.Value(RequestID)
        if reqID != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.String(RequestID, reqID.(string)))
        }</span>

        <span class="cov0" title="0">l.logger.InfoContext(ctx, fmt.Sprintf(msg, args...), attrs...)</span>
}

func (l *logger) Errorf(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        attrs := make([]any, 0)
        attrs = append(attrs, slog.String(ServiceName, l.serviceName))

        reqID := ctx.Value(RequestID)
        if reqID != nil </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.String(RequestID, reqID.(string)))
        }</span>

        <span class="cov0" title="0">l.logger.ErrorContext(ctx, fmt.Sprintf(msg, args...), attrs...)</span>
}

func (l *logger) Fatalf(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        l.Errorf(ctx, msg, args...)
        os.Exit(1)
}</span>

func GetLoggerFromCtx(ctx context.Context) Logger <span class="cov0" title="0">{
        return ctx.Value(LoggerKey).(Logger)
}</span>

func CtxWithLogger(ctx context.Context, lg Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LoggerKey, lg)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package gmail

import (
        "bytes"
        "fmt"
        "html/template"
        "net/smtp"

        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/application/config"
        "gitlab.crja72.ru/gospec/go9/netevent/notification-service/internal/domain"
)

const templatePath = "./templates/mail.html"

type Gmail struct {
        mailTemplate *template.Template
        auth         smtp.Auth
        address      string
        from         string
}

func New(cfg config.Mail) *Gmail <span class="cov0" title="0">{
        return &amp;Gmail{
                mailTemplate: template.Must(template.ParseFiles(templatePath)),
                auth:         smtp.PlainAuth("", cfg.Username, cfg.Password, cfg.Host),
                address:      fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
                from:         cfg.Username,
        }
}</span>

func (g *Gmail) Send(subject string, msg domain.Notification) error <span class="cov0" title="0">{
        var body bytes.Buffer

        if err := g.mailTemplate.Execute(&amp;body, msg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute mail template: %w", err)
        }</span>

        <span class="cov0" title="0">headers := "MIME-version: 1.0;\nContent-Type: text/html; charset=\"UTF-8\";"
        mail := "Subject: " + subject + "\n" +
                headers + "\n\n" +
                body.String()

        if err := smtp.SendMail(g.address, g.auth, g.from, []string{msg.UserEmail}, []byte(mail)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send mail: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
